Qapla reference monitor (QRM)
=============================
Reference: https://people.mpi-sws.org/~aasthakm/files/qapla.pdf
This code provides a standalone implementation of QRM. An example
script is provided, which can be used to generate re-written SQL
queries for mysql DB. The re-written queries can be executed
manually on the DB backend.

Steps to use:
(1) Setup your database in mysql.
(2) Create an administrative user (e.g. qapla).
(3) Configure DB_NAME and DB_ADMIN in config.h to the name of your
database and user respectively.
(4) Define your policies (see below)
(5) Generate re-written queries using refmon script
(6) Execute generated queries on database

QRM can be integrated with a database adapter, to provide policy
enforcement for an application at runtime.

Dependencies
============
QRM relies on a mysql parser, which was taken from mysql workbench.
The parser requires antlr3 and boost libraries. It has been tested with
the following versions of the libraries.
antlr3.4 - http://www.antlr3.org/download/C/libantlr3c-3.4.tar.gz
boost-1.58

Qapla has been tested on mysql 5.7.11, however, it is largely
database-independent.

Directory structure
===================
mysqlparser - taken from mysql workbench
policyapi - API to generate policy code
dlog_pi, sql_pi - policy interpreter and rewriting code
qinfo - internal datastructures of QRM
dbif - wrapper on C mysql connector API
hotcrp - policies for HotCRP use case (schema based on v2.99)
udf - examples for writing UDF functions
common - code shared by above directories
utils - utilities
examples - small tests for QRM and the query parser
bench - QRM with statistics generation for internal overheads


Schema specification
====================
Currently, QRM requires a custom in-memory schema of the underlying DB schema.
A sample code for generating QRM schema for the HotCRP DB can be found in hotcrp_db.c.


Policy specification
====================
Qapla policies are written as a combination of datalog-like predicates and SQL.
Datalog is used to specify parts of a policy that could be pre-evaluated before
rewriting the SQL query, which may improve the efficiency of the rewritten query.
All datalog predicates can be specified in SQL as well.

Qapla predicate data types:
---------------------------------------------------------------------------
datatype                | shorthand |	description
---------------------------------------------------------------------------
tuple                   | tup       | max 8 elements, tuples or basic types
integer                 | int       |	8 bytes
variable                | var       |	2 bytes
variable-length string  | varlen    | <start offset, end offset in a tuple>

Qapla predicates:
---------------------------------------------------------------------------
predicate | description                             | arguments
---------------------------------------------------------------------------
SESSID(x) | x is authenticated user in the session  | x: var or varlen
TIME(x)   | x is timestamp                          | x: var or int
GT(x,y)   | x > y                                   | x: var or int, y: int
GE(x,y)   | x >= y                                  | x: var or int, y: int
LT(x,y)   | x < y                                   | x: var or int, y: int
LE(x,y)   | x <= y                                  | x: var or int, y: int
EQ(x,y)   | x == y                                  | x: var or int, y: int
NE(x,y)   | x != y                                  | x: var or int, y: int
          |                                         |
SQL(x,y)  | x: table on which policy specified,     | x: int,
          | y: SQL predicate for the table          | y: varlen

All the predicates except SQL(x) are used to specify datalog predicates.
The API for creating the above predicates is defined in policyapi/dlog_preds.h


Constructing a qapla policy
===========================

General form of Qapla policy implementation:
<DLOG_1>, <DLOG_2>, ..., <DLOG_n> | <SQL_1>, <SQL_2>, ..., <SQL_n>

Examples of valid Qapla policies:
(1) <SQL> // this is same as <true> | <SQL>, i.e. the DLOG predicates of the clause evaluates to true
(2) <false>
(3) <DLOG_1>, <DLOG_3> | <SQL_1>, <SQL_2>, <SQL_3> // the second clause has DLOG predicates evaluating to true


Steps required to prepare every policy (see examples in hotcrp/hotcrp_qapla_pol_db.c):

qapla_set_perm_clauses(qp, QP_PERM_READ, N) // number of OR clauses in the read perm

perm = qapla_start_perm(qp, QP_PERM_READ) // start read perm spec


// your custom policy predicates here


...

op = qapla_start_perm_clause(qp, QP_PERM_READ, CTYPE_DLOG, N-1) // start DLOG clause N-1

// your custom policy predicates here

qapla_end_perm_clause(qp, QP_PERM_READ, CTYPE_SQL, N-1, op) // end SQL clause N-1

op = qapla_start_perm_clause(qp, QP_PERM_READ, CTYPE_SQL, 0) // start SQL clause 0

// your custom policy predicates here

qapla_end_perm_clause(qp, QP_PERM_READ, CTYPE_SQL, 0, op) // end SQL clause 0

...

op = qapla_start_perm_clause(qp, QP_PERM_READ, CTYPE_SQL, N-1) // start SQL clause N-1

// your custom policy predicates here

qapla_end_perm_clause(qp, QP_PERM_READ, CTYPE_SQL, N-1, op) // end SQL clause N-1

qapla_end_perm(qp, QP_PERM_READ) // end read perm spec

	
Associating a policy with a set of table columns
================================================
Each policy must be associated with one or more columns of a table. A column must also
have query expression type associated with it. The corresponding policy is applied
only when the column is used in a query in the same expression as specified in the policy,
otherwise a restrictive false policy will be applied to the query.

Supported query operators:
PROJECT    | column can be used in a SELECT expression of the query
FILTER     | column can be used in WHERE expression of the query
JOIN_COND  | column can only be used in a join condition
GROUP      | column can only be used in a GROUP BY expression
HAVING     | column can only be used in a HAVING expression
ORDER      | column can only be used in an ORDER BY expression

Optionally, a column may also have one or more transformation or aggregate query operators
associated with it. The corresponding policy is applied only when the column is used in a query
with the same operator as specified in the policy, otherwise a more restrictive policy will
be applied to the query.

aggregate operators:
COUNT | count
SUM   | sum
AVG   | average
STD   | standard deviation
MAX   | maximum
MIN   | minimum

One can define custom transformation operators based on used UDFs in the database.

See examples of how to associate a policy with a list of columns in hotcrp_load_standard_policies().


Qapla policy clusters
=====================
Policies may be organized into clusters, where a cluster defines the restrictiveness
relationship between member policies. Each policy belongs to at most policy cluster.
If policies P1, P2, P3 are such that P1 <= P2 <= P3, where x <= y implies x is less
restrictive than y, then P1, P2, P3 are placed in a single cluster. If two policies
are unrelated, they belong to different clusters.

Qapla policy clusters are of 3 types:
AND_NON_AGGR | policies for non-aggregate SQL queries
AND_AGGR     | policies for aggregate SQL queries
OR_NON_AGGR  | cluster for all individual policies that do not have any restrictiveness
             |  relationship with other policies

For policies in AND_NON_AGGR and AND_AGGR cluster, one must explicitly specify the
restrictiveness relationship between the policies.

See examples in hotcrp_load_standard_policies() in hotcrp/hotcrp_pol_db.c


Publications
============
Qapla: Policy compliance for database-backed systems (USENIX Security'17)
Aastha Mehta, Eslam Elnikety, Katura Harvey, Deepak Garg, Peter Druschel
https://people.mpi-sws.org/~aasthakm/files/qapla.pdf

If you use this code in your work, please cite the paper above.


Contact
=======
Aastha Mehta <aasthakm@mpi-sws.org>
